{"version":3,"file":"8511.608c3d45.async.js","mappings":"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","sources":["webpack://web/./node_modules/@tanstack/query-core/build/modern/queryObserver.js","webpack://web/./node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js","webpack://web/./node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js","webpack://web/./node_modules/@tanstack/react-query/build/modern/isRestoring.js","webpack://web/./node_modules/@tanstack/react-query/build/modern/suspense.js","webpack://web/./node_modules/@tanstack/react-query/build/modern/useBaseQuery.js","webpack://web/./node_modules/@tanstack/query-core/build/modern/mutationObserver.js","webpack://web/./node_modules/@tanstack/react-query/build/modern/useMutation.js","webpack://web/./node_modules/@tanstack/react-query/build/modern/useQuery.js","webpack://web/./node_modules/@tanstack/react-query/build/modern/utils.js"],"sourcesContent":["// src/queryObserver.ts\nimport { focusManager } from \"./focusManager.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { fetchState } from \"./query.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { pendingThenable } from \"./thenable.js\";\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  shallowEqualObjects,\n  timeUntilStale\n} from \"./utils.js\";\nvar QueryObserver = class extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.options = options;\n    this.#client = client;\n    this.#selectError = null;\n    this.#currentThenable = pendingThenable();\n    if (!this.options.experimental_prefetchInRender) {\n      this.#currentThenable.reject(\n        new Error(\"experimental_prefetchInRender feature flag is not enabled\")\n      );\n    }\n    this.bindMethods();\n    this.setOptions(options);\n  }\n  #client;\n  #currentQuery = void 0;\n  #currentQueryInitialState = void 0;\n  #currentResult = void 0;\n  #currentResultState;\n  #currentResultOptions;\n  #currentThenable;\n  #selectError;\n  #selectFn;\n  #selectResult;\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData;\n  #staleTimeoutId;\n  #refetchIntervalId;\n  #currentRefetchInterval;\n  #trackedProps = /* @__PURE__ */ new Set();\n  bindMethods() {\n    this.refetch = this.refetch.bind(this);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this);\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch();\n      } else {\n        this.updateResult();\n      }\n      this.#updateTimers();\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect\n    );\n  }\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus\n    );\n  }\n  destroy() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.#clearStaleTimeout();\n    this.#clearRefetchInterval();\n    this.#currentQuery.removeObserver(this);\n  }\n  setOptions(options) {\n    const prevOptions = this.options;\n    const prevQuery = this.#currentQuery;\n    this.options = this.#client.defaultQueryOptions(options);\n    if (this.options.enabled !== void 0 && typeof this.options.enabled !== \"boolean\" && typeof this.options.enabled !== \"function\" && typeof resolveEnabled(this.options.enabled, this.#currentQuery) !== \"boolean\") {\n      throw new Error(\n        \"Expected enabled to be a boolean or a callback that returns a boolean\"\n      );\n    }\n    this.#updateQuery();\n    this.#currentQuery.setOptions(this.options);\n    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {\n      this.#client.getQueryCache().notify({\n        type: \"observerOptionsUpdated\",\n        query: this.#currentQuery,\n        observer: this\n      });\n    }\n    const mounted = this.hasListeners();\n    if (mounted && shouldFetchOptionally(\n      this.#currentQuery,\n      prevQuery,\n      this.options,\n      prevOptions\n    )) {\n      this.#executeFetch();\n    }\n    this.updateResult();\n    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || resolveStaleTime(this.options.staleTime, this.#currentQuery) !== resolveStaleTime(prevOptions.staleTime, this.#currentQuery))) {\n      this.#updateStaleTimeout();\n    }\n    const nextRefetchInterval = this.#computeRefetchInterval();\n    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || nextRefetchInterval !== this.#currentRefetchInterval)) {\n      this.#updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n  getOptimisticResult(options) {\n    const query = this.#client.getQueryCache().build(this.#client, options);\n    const result = this.createResult(query, options);\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      this.#currentResult = result;\n      this.#currentResultOptions = this.options;\n      this.#currentResultState = this.#currentQuery.state;\n    }\n    return result;\n  }\n  getCurrentResult() {\n    return this.#currentResult;\n  }\n  trackResult(result, onPropTracked) {\n    const trackedResult = {};\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackProp(key);\n          onPropTracked?.(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n  trackProp(key) {\n    this.#trackedProps.add(key);\n  }\n  getCurrentQuery() {\n    return this.#currentQuery;\n  }\n  refetch({ ...options } = {}) {\n    return this.fetch({\n      ...options\n    });\n  }\n  fetchOptimistic(options) {\n    const defaultedOptions = this.#client.defaultQueryOptions(options);\n    const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n  fetch(fetchOptions) {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true\n    }).then(() => {\n      this.updateResult();\n      return this.#currentResult;\n    });\n  }\n  #executeFetch(fetchOptions) {\n    this.#updateQuery();\n    let promise = this.#currentQuery.fetch(\n      this.options,\n      fetchOptions\n    );\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop);\n    }\n    return promise;\n  }\n  #updateStaleTimeout() {\n    this.#clearStaleTimeout();\n    const staleTime = resolveStaleTime(\n      this.options.staleTime,\n      this.#currentQuery\n    );\n    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {\n      return;\n    }\n    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime);\n    const timeout = time + 1;\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n  #computeRefetchInterval() {\n    return (typeof this.options.refetchInterval === \"function\" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;\n  }\n  #updateRefetchInterval(nextInterval) {\n    this.#clearRefetchInterval();\n    this.#currentRefetchInterval = nextInterval;\n    if (isServer || resolveEnabled(this.options.enabled, this.#currentQuery) === false || !isValidTimeout(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {\n      return;\n    }\n    this.#refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.#executeFetch();\n      }\n    }, this.#currentRefetchInterval);\n  }\n  #updateTimers() {\n    this.#updateStaleTimeout();\n    this.#updateRefetchInterval(this.#computeRefetchInterval());\n  }\n  #clearStaleTimeout() {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId);\n      this.#staleTimeoutId = void 0;\n    }\n  }\n  #clearRefetchInterval() {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId);\n      this.#refetchIntervalId = void 0;\n    }\n  }\n  createResult(query, options) {\n    const prevQuery = this.#currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.#currentResult;\n    const prevResultState = this.#currentResultState;\n    const prevResultOptions = this.#currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;\n    const { state } = query;\n    let newState = { ...state };\n    let isPlaceholderData = false;\n    let data;\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n      if (fetchOnMount || fetchOptionally) {\n        newState = {\n          ...newState,\n          ...fetchState(state.data, query.options)\n        };\n      }\n      if (options._optimisticResults === \"isRestoring\") {\n        newState.fetchStatus = \"idle\";\n      }\n    }\n    let { error, errorUpdatedAt, status } = newState;\n    data = newState.data;\n    let skipSelect = false;\n    if (options.placeholderData !== void 0 && data === void 0 && status === \"pending\") {\n      let placeholderData;\n      if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {\n        placeholderData = prevResult.data;\n        skipSelect = true;\n      } else {\n        placeholderData = typeof options.placeholderData === \"function\" ? options.placeholderData(\n          this.#lastQueryWithDefinedData?.state.data,\n          this.#lastQueryWithDefinedData\n        ) : options.placeholderData;\n      }\n      if (placeholderData !== void 0) {\n        status = \"success\";\n        data = replaceData(\n          prevResult?.data,\n          placeholderData,\n          options\n        );\n        isPlaceholderData = true;\n      }\n    }\n    if (options.select && data !== void 0 && !skipSelect) {\n      if (prevResult && data === prevResultState?.data && options.select === this.#selectFn) {\n        data = this.#selectResult;\n      } else {\n        try {\n          this.#selectFn = options.select;\n          data = options.select(data);\n          data = replaceData(prevResult?.data, data, options);\n          this.#selectResult = data;\n          this.#selectError = null;\n        } catch (selectError) {\n          this.#selectError = selectError;\n        }\n      }\n    }\n    if (this.#selectError) {\n      error = this.#selectError;\n      data = this.#selectResult;\n      errorUpdatedAt = Date.now();\n      status = \"error\";\n    }\n    const isFetching = newState.fetchStatus === \"fetching\";\n    const isPending = status === \"pending\";\n    const isError = status === \"error\";\n    const isLoading = isPending && isFetching;\n    const hasData = data !== void 0;\n    const result = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === \"success\",\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === \"paused\",\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      promise: this.#currentThenable\n    };\n    const nextResult = result;\n    if (this.options.experimental_prefetchInRender) {\n      const finalizeThenableIfPossible = (thenable) => {\n        if (nextResult.status === \"error\") {\n          thenable.reject(nextResult.error);\n        } else if (nextResult.data !== void 0) {\n          thenable.resolve(nextResult.data);\n        }\n      };\n      const recreateThenable = () => {\n        const pending = this.#currentThenable = nextResult.promise = pendingThenable();\n        finalizeThenableIfPossible(pending);\n      };\n      const prevThenable = this.#currentThenable;\n      switch (prevThenable.status) {\n        case \"pending\":\n          if (query.queryHash === prevQuery.queryHash) {\n            finalizeThenableIfPossible(prevThenable);\n          }\n          break;\n        case \"fulfilled\":\n          if (nextResult.status === \"error\" || nextResult.data !== prevThenable.value) {\n            recreateThenable();\n          }\n          break;\n        case \"rejected\":\n          if (nextResult.status !== \"error\" || nextResult.error !== prevThenable.reason) {\n            recreateThenable();\n          }\n          break;\n      }\n    }\n    return nextResult;\n  }\n  updateResult() {\n    const prevResult = this.#currentResult;\n    const nextResult = this.createResult(this.#currentQuery, this.options);\n    this.#currentResultState = this.#currentQuery.state;\n    this.#currentResultOptions = this.options;\n    if (this.#currentResultState.data !== void 0) {\n      this.#lastQueryWithDefinedData = this.#currentQuery;\n    }\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n    this.#currentResult = nextResult;\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n      const { notifyOnChangeProps } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === \"function\" ? notifyOnChangeProps() : notifyOnChangeProps;\n      if (notifyOnChangePropsValue === \"all\" || !notifyOnChangePropsValue && !this.#trackedProps.size) {\n        return true;\n      }\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps\n      );\n      if (this.options.throwOnError) {\n        includedProps.add(\"error\");\n      }\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key;\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n    this.#notify({ listeners: shouldNotifyListeners() });\n  }\n  #updateQuery() {\n    const query = this.#client.getQueryCache().build(this.#client, this.options);\n    if (query === this.#currentQuery) {\n      return;\n    }\n    const prevQuery = this.#currentQuery;\n    this.#currentQuery = query;\n    this.#currentQueryInitialState = query.state;\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n  onQueryUpdate() {\n    this.updateResult();\n    if (this.hasListeners()) {\n      this.#updateTimers();\n    }\n  }\n  #notify(notifyOptions) {\n    notifyManager.batch(() => {\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult);\n        });\n      }\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: \"observerResultsUpdated\"\n      });\n    });\n  }\n};\nfunction shouldLoadOnMount(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === \"error\" && options.retryOnMount === false);\n}\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\nfunction shouldFetchOn(query, options, field) {\n  if (resolveEnabled(options.enabled, query) !== false) {\n    const value = typeof field === \"function\" ? field(query) : field;\n    return value === \"always\" || value !== false && isStale(query, options);\n  }\n  return false;\n}\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== \"error\") && isStale(query, options);\n}\nfunction isStale(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));\n}\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult) {\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  }\n  return false;\n}\nexport {\n  QueryObserver\n};\n//# sourceMappingURL=queryObserver.js.map","\"use client\";\n\n// src/QueryErrorResetBoundary.tsx\nimport * as React from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nfunction createValue() {\n  let isReset = false;\n  return {\n    clearReset: () => {\n      isReset = false;\n    },\n    reset: () => {\n      isReset = true;\n    },\n    isReset: () => {\n      return isReset;\n    }\n  };\n}\nvar QueryErrorResetBoundaryContext = React.createContext(createValue());\nvar useQueryErrorResetBoundary = () => React.useContext(QueryErrorResetBoundaryContext);\nvar QueryErrorResetBoundary = ({\n  children\n}) => {\n  const [value] = React.useState(() => createValue());\n  return /* @__PURE__ */ jsx(QueryErrorResetBoundaryContext.Provider, { value, children: typeof children === \"function\" ? children(value) : children });\n};\nexport {\n  QueryErrorResetBoundary,\n  useQueryErrorResetBoundary\n};\n//# sourceMappingURL=QueryErrorResetBoundary.js.map","\"use client\";\n\n// src/errorBoundaryUtils.ts\nimport * as React from \"react\";\nimport { shouldThrowError } from \"./utils.js\";\nvar ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {\n  if (options.suspense || options.throwOnError || options.experimental_prefetchInRender) {\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false;\n    }\n  }\n};\nvar useClearResetErrorBoundary = (errorResetBoundary) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset();\n  }, [errorResetBoundary]);\n};\nvar getHasError = ({\n  result,\n  errorResetBoundary,\n  throwOnError,\n  query,\n  suspense\n}) => {\n  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && (suspense && result.data === void 0 || shouldThrowError(throwOnError, [result.error, query]));\n};\nexport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary\n};\n//# sourceMappingURL=errorBoundaryUtils.js.map","\"use client\";\n\n// src/isRestoring.ts\nimport * as React from \"react\";\nvar IsRestoringContext = React.createContext(false);\nvar useIsRestoring = () => React.useContext(IsRestoringContext);\nvar IsRestoringProvider = IsRestoringContext.Provider;\nexport {\n  IsRestoringProvider,\n  useIsRestoring\n};\n//# sourceMappingURL=isRestoring.js.map","// src/suspense.ts\nvar defaultThrowOnError = (_error, query) => query.state.data === void 0;\nvar ensureSuspenseTimers = (defaultedOptions) => {\n  const originalStaleTime = defaultedOptions.staleTime;\n  if (defaultedOptions.suspense) {\n    defaultedOptions.staleTime = typeof originalStaleTime === \"function\" ? (...args) => Math.max(originalStaleTime(...args), 1e3) : Math.max(originalStaleTime ?? 1e3, 1e3);\n    if (typeof defaultedOptions.gcTime === \"number\") {\n      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1e3);\n    }\n  }\n};\nvar willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;\nvar shouldSuspend = (defaultedOptions, result) => defaultedOptions?.suspense && result.isPending;\nvar fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {\n  errorResetBoundary.clearReset();\n});\nexport {\n  defaultThrowOnError,\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch\n};\n//# sourceMappingURL=suspense.js.map","\"use client\";\n\n// src/useBaseQuery.ts\nimport * as React from \"react\";\nimport { isServer, notifyManager } from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nimport { useQueryErrorResetBoundary } from \"./QueryErrorResetBoundary.js\";\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary\n} from \"./errorBoundaryUtils.js\";\nimport { useIsRestoring } from \"./isRestoring.js\";\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch\n} from \"./suspense.js\";\nimport { noop } from \"./utils.js\";\nfunction useBaseQuery(options, Observer, queryClient) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (typeof options !== \"object\" || Array.isArray(options)) {\n      throw new Error(\n        'Bad argument type. Starting with v5, only the \"Object\" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'\n      );\n    }\n  }\n  const client = useQueryClient(queryClient);\n  const isRestoring = useIsRestoring();\n  const errorResetBoundary = useQueryErrorResetBoundary();\n  const defaultedOptions = client.defaultQueryOptions(options);\n  client.getDefaultOptions().queries?._experimental_beforeQuery?.(\n    defaultedOptions\n  );\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!defaultedOptions.queryFn) {\n      console.error(\n        `[${defaultedOptions.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`\n      );\n    }\n  }\n  defaultedOptions._optimisticResults = isRestoring ? \"isRestoring\" : \"optimistic\";\n  ensureSuspenseTimers(defaultedOptions);\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);\n  useClearResetErrorBoundary(errorResetBoundary);\n  const isNewCacheEntry = !client.getQueryCache().get(defaultedOptions.queryHash);\n  const [observer] = React.useState(\n    () => new Observer(\n      client,\n      defaultedOptions\n    )\n  );\n  const result = observer.getOptimisticResult(defaultedOptions);\n  const shouldSubscribe = !isRestoring && options.subscribed !== false;\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => {\n        const unsubscribe = shouldSubscribe ? observer.subscribe(notifyManager.batchCalls(onStoreChange)) : noop;\n        observer.updateResult();\n        return unsubscribe;\n      },\n      [observer, shouldSubscribe]\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult()\n  );\n  React.useEffect(() => {\n    observer.setOptions(defaultedOptions);\n  }, [defaultedOptions, observer]);\n  if (shouldSuspend(defaultedOptions, result)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);\n  }\n  if (getHasError({\n    result,\n    errorResetBoundary,\n    throwOnError: defaultedOptions.throwOnError,\n    query: client.getQueryCache().get(defaultedOptions.queryHash),\n    suspense: defaultedOptions.suspense\n  })) {\n    throw result.error;\n  }\n  ;\n  client.getDefaultOptions().queries?._experimental_afterQuery?.(\n    defaultedOptions,\n    result\n  );\n  if (defaultedOptions.experimental_prefetchInRender && !isServer && willFetch(result, isRestoring)) {\n    const promise = isNewCacheEntry ? (\n      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted\n      fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n    ) : (\n      // subscribe to the \"cache promise\" so that we can finalize the currentThenable once data comes in\n      client.getQueryCache().get(defaultedOptions.queryHash)?.promise\n    );\n    promise?.catch(noop).finally(() => {\n      observer.updateResult();\n    });\n  }\n  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;\n}\nexport {\n  useBaseQuery\n};\n//# sourceMappingURL=useBaseQuery.js.map","// src/mutationObserver.ts\nimport { getDefaultState } from \"./mutation.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { hashKey, shallowEqualObjects } from \"./utils.js\";\nvar MutationObserver = class extends Subscribable {\n  #client;\n  #currentResult = void 0;\n  #currentMutation;\n  #mutateOptions;\n  constructor(client, options) {\n    super();\n    this.#client = client;\n    this.setOptions(options);\n    this.bindMethods();\n    this.#updateResult();\n  }\n  bindMethods() {\n    this.mutate = this.mutate.bind(this);\n    this.reset = this.reset.bind(this);\n  }\n  setOptions(options) {\n    const prevOptions = this.options;\n    this.options = this.#client.defaultMutationOptions(options);\n    if (!shallowEqualObjects(this.options, prevOptions)) {\n      this.#client.getMutationCache().notify({\n        type: \"observerOptionsUpdated\",\n        mutation: this.#currentMutation,\n        observer: this\n      });\n    }\n    if (prevOptions?.mutationKey && this.options.mutationKey && hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)) {\n      this.reset();\n    } else if (this.#currentMutation?.state.status === \"pending\") {\n      this.#currentMutation.setOptions(this.options);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#currentMutation?.removeObserver(this);\n    }\n  }\n  onMutationUpdate(action) {\n    this.#updateResult();\n    this.#notify(action);\n  }\n  getCurrentResult() {\n    return this.#currentResult;\n  }\n  reset() {\n    this.#currentMutation?.removeObserver(this);\n    this.#currentMutation = void 0;\n    this.#updateResult();\n    this.#notify();\n  }\n  mutate(variables, options) {\n    this.#mutateOptions = options;\n    this.#currentMutation?.removeObserver(this);\n    this.#currentMutation = this.#client.getMutationCache().build(this.#client, this.options);\n    this.#currentMutation.addObserver(this);\n    return this.#currentMutation.execute(variables);\n  }\n  #updateResult() {\n    const state = this.#currentMutation?.state ?? getDefaultState();\n    this.#currentResult = {\n      ...state,\n      isPending: state.status === \"pending\",\n      isSuccess: state.status === \"success\",\n      isError: state.status === \"error\",\n      isIdle: state.status === \"idle\",\n      mutate: this.mutate,\n      reset: this.reset\n    };\n  }\n  #notify(action) {\n    notifyManager.batch(() => {\n      if (this.#mutateOptions && this.hasListeners()) {\n        const variables = this.#currentResult.variables;\n        const context = this.#currentResult.context;\n        if (action?.type === \"success\") {\n          this.#mutateOptions.onSuccess?.(action.data, variables, context);\n          this.#mutateOptions.onSettled?.(action.data, null, variables, context);\n        } else if (action?.type === \"error\") {\n          this.#mutateOptions.onError?.(action.error, variables, context);\n          this.#mutateOptions.onSettled?.(\n            void 0,\n            action.error,\n            variables,\n            context\n          );\n        }\n      }\n      this.listeners.forEach((listener) => {\n        listener(this.#currentResult);\n      });\n    });\n  }\n};\nexport {\n  MutationObserver\n};\n//# sourceMappingURL=mutationObserver.js.map","\"use client\";\n\n// src/useMutation.ts\nimport * as React from \"react\";\nimport { MutationObserver, notifyManager } from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nimport { noop, shouldThrowError } from \"./utils.js\";\nfunction useMutation(options, queryClient) {\n  const client = useQueryClient(queryClient);\n  const [observer] = React.useState(\n    () => new MutationObserver(\n      client,\n      options\n    )\n  );\n  React.useEffect(() => {\n    observer.setOptions(options);\n  }, [observer, options]);\n  const result = React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer]\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult()\n  );\n  const mutate = React.useCallback(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop);\n    },\n    [observer]\n  );\n  if (result.error && shouldThrowError(observer.options.throwOnError, [result.error])) {\n    throw result.error;\n  }\n  return { ...result, mutate, mutateAsync: result.mutate };\n}\nexport {\n  useMutation\n};\n//# sourceMappingURL=useMutation.js.map","\"use client\";\n\n// src/useQuery.ts\nimport { QueryObserver } from \"@tanstack/query-core\";\nimport { useBaseQuery } from \"./useBaseQuery.js\";\nfunction useQuery(options, queryClient) {\n  return useBaseQuery(options, QueryObserver, queryClient);\n}\nexport {\n  useQuery\n};\n//# sourceMappingURL=useQuery.js.map","// src/utils.ts\nfunction shouldThrowError(throwError, params) {\n  if (typeof throwError === \"function\") {\n    return throwError(...params);\n  }\n  return !!throwError;\n}\nfunction noop() {\n}\nexport {\n  noop,\n  shouldThrowError\n};\n//# sourceMappingURL=utils.js.map"],"names":["QueryObserver","constructor","client","options","super","this","experimental_prefetchInRender","reject","Error","bindMethods","setOptions","Set","refetch","bind","onSubscribe","listeners","size","addObserver","shouldFetchOnMount","updateResult","onUnsubscribe","hasListeners","destroy","shouldFetchOnReconnect","shouldFetchOn","refetchOnReconnect","shouldFetchOnWindowFocus","refetchOnWindowFocus","removeObserver","prevOptions","prevQuery","defaultQueryOptions","enabled","_defaulted","getQueryCache","notify","type","query","observer","mounted","shouldFetchOptionally","staleTime","nextRefetchInterval","getOptimisticResult","build","result","createResult","optimisticResult","getCurrentResult","shouldAssignObserverCurrentProperties","state","trackResult","onPropTracked","trackedResult","Object","keys","forEach","key","defineProperty","configurable","enumerable","get","trackProp","add","getCurrentQuery","fetch","fetchOptimistic","defaultedOptions","then","fetchOptions","cancelRefetch","promise","throwOnError","catch","isStale","timeout","dataUpdatedAt","setTimeout","refetchInterval","nextInterval","setInterval","refetchIntervalInBackground","isFocused","clearTimeout","clearInterval","prevResult","prevResultState","prevResultOptions","queryInitialState","data","newState","isPlaceholderData","_optimisticResults","fetchOnMount","fetchOptionally","fetchStatus","error","errorUpdatedAt","status","skipSelect","placeholderData","select","selectError","Date","now","isFetching","isPending","isError","isLoading","hasData","nextResult","isSuccess","isInitialLoading","failureCount","fetchFailureCount","failureReason","fetchFailureReason","errorUpdateCount","isFetched","dataUpdateCount","isFetchedAfterMount","isRefetching","isLoadingError","isPaused","isRefetchError","finalizeThenableIfPossible","thenable","resolve","recreateThenable","pending","prevThenable","queryHash","value","reason","notifyOnChangeProps","notifyOnChangePropsValue","includedProps","some","typedKey","has","shouldNotifyListeners","onQueryUpdate","notifyOptions","batch","listener","retryOnMount","shouldLoadOnMount","refetchOnMount","field","suspense","isStaleByTime","createValue","isReset","clearReset","reset","QueryErrorResetBoundaryContext","useQueryErrorResetBoundary","ensurePreventErrorBoundaryRetry","errorResetBoundary","useClearResetErrorBoundary","getHasError","IsRestoringContext","useIsRestoring","ensureSuspenseTimers","Provider","originalStaleTime","args","Math","max","gcTime","willFetch","isRestoring","shouldSuspend","useBaseQuery","Observer","queryClient","getDefaultOptions","queries","_experimental_beforeQuery","isNewCacheEntry","shouldSubscribe","subscribed","onStoreChange","unsubscribe","subscribe","notifyManager","batchCalls","_experimental_afterQuery","finally","MutationObserver","mutate","defaultMutationOptions","getMutationCache","mutation","mutationKey","onMutationUpdate","action","variables","execute","isIdle","context","onSuccess","onSettled","onError","useMutation","mutateOptions","mutateAsync","useQuery","shouldThrowError","throwError","params","noop"],"sourceRoot":""}